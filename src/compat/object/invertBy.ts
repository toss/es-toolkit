import { isNil } from '../../predicate';

/**
 * Creates an object where the keys are generated by applying the provided iteratee function
 * to the values of the input object. The value for each generated key is an array of property names (keys)
 * that correspond to the values that produced the key.
 *
 * If no iteratee is provided, the property values are converted to strings and used as keys.
 *
 * @template T - The type of the input object.
 * @param {T | null | undefined} object - The object to iterate over. Can be null or undefined. If null or undefined, returns an empty object.
 * @param {(value: T[keyof T]) => string} [iteratee] - Optional. A function that generates a key based on each value in the object.
 * If not provided, the function defaults to converting the value to a string.
 *
 * @returns {Record<string, string[]>} An object where the keys are generated by the iteratee, and the values
 * are arrays of property names (keys) from the input object that correspond to those values.
 *
 * @example
 * const obj = { a: 1, b: 2, c: 1 };
 * const result = invertBy(obj);
 * // result => { '1': ['a', 'c'], '2': ['b'] }
 *
 * @example
 * const obj = { a: 1, b: 2, c: 1 };
 * const result = invertBy(obj, value => `group${value}`);
 * // result => { 'group1': ['a', 'c'], 'group2': ['b'] }
 */
export function invertBy<T extends object>(
  object: T | null | undefined,
  iteratee?: (value: T[keyof T]) => string
): Record<string, string[]> {
  const result = {} as Record<string, string[]>;

  if (isNil(object)) {
    return result;
  }

  const getIteratee = iteratee ?? ((value: T[keyof T]) => value as unknown as string);

  for (const key in object) {
    const value = object[key];
    const valueStr = getIteratee(value);

    if (Array.isArray(result[valueStr])) {
      result[valueStr].push(key);
    } else {
      result[valueStr] = [key];
    }
  }

  return result;
}
