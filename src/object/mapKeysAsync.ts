import { limitAsync } from '../array/limitAsync.ts';

interface MapKeysAsyncOptions {
  concurrency?: number;
}

/**
 * Creates a new object with the same values as the given object, but with keys generated
 * by running each own enumerable property of the object through the async iteratee function.
 *
 * @template T - The type of the object.
 * @template K - The type of the new keys generated by the iteratee function.
 *
 * @param {T} object - The object to iterate over.
 * @param {(value: T[keyof T], key: keyof T, object: T) => Promise<K>} getNewKey - The async function invoked per own enumerable property.
 * @param {MapKeysAsyncOptions} [options] Optional configuration object.
 * @returns {Promise<Record<K, T[keyof T]>>} - A promise that resolves to the new mapped object.
 *
 * @example
 * // Example usage:
 * const obj = { a: 1, b: 2 };
 * const result = await mapKeysAsync(obj, async (value, key) => key + value);
 * console.log(result); // { a1: 1, b2: 2 }
 */
export async function mapKeysAsync<T extends Record<PropertyKey, any>, K extends PropertyKey>(
  object: T,
  getNewKey: (value: T[keyof T], key: keyof T, object: T) => Promise<K>,
  options?: MapKeysAsyncOptions
): Promise<Record<K, T[keyof T]>> {
  const result = {} as Record<K, T[keyof T]>;
  const keys = Object.keys(object) as Array<keyof T>;

  if (options?.concurrency) {
    getNewKey = limitAsync(getNewKey, options.concurrency);
  }

  await Promise.all(
    keys.map(async key => {
      const value = object[key];
      result[await getNewKey(value, key, object)] = value;
    })
  );

  return result;
}
